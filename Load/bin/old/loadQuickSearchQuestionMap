#!/usr/bin/env python

from __future__ import print_function
import sys
import psycopg2
import argparse
from ConfigParser import SafeConfigParser
import os

def warning(prefix, *objs):
    print(prefix, *objs, file=sys.stderr)

"""
puts a fake section into the gus.config file so that ConfigParser can
be used to retrieve db access informatoin
"""
class FakeSecHead(object):
    def __init__(self, fp):
        self.fp = fp
        self.sechead = '[section]\n'

    def readline(self):
        if self.sechead:
            try: 
                return self.sechead
            finally: 
                self.sechead = None
        else: 
            return self.fp.readline()

def createTable(dbh):
    cursor = dbh.cursor()
    cursor.execute("DROP TABLE IF EXISTS QuickSearchQuestion")

    sql = "CREATE TABLE QuickSearchQuestion"
    sql = sql + " (qs_question_id INTEGER PRIMARY KEY"
    sql = sql + ", question_name_display VARCHAR(50)"
    sql = sql + ", question_name_internal VARCHAR(50)"
    sql = sql + ", input_placeholder VARCHAR(250)"
    sql = sql + ", help_text VARCHAR(250)"
    sql = sql + ", param_name VARCHAR(250)"
    sql = sql + ", record_type VARCHAR(20)"
    sql = sql + ", hide INTEGER)"

    warning("DEBUG:", sql)

    cursor.execute(sql)

def loadQuestions(questions, dbh, commit):     
    sql = "INSERT INTO QuickSearchQuestion (qs_question_id, question_name_display, question_name_internal, input_placeholder, help_text, param_name, record_type)"
    sql = sql + " VALUES (%s, %s, %s, %s, %s, %s, %s)"

    cursor = dbh.cursor()
    cursor.executemany(sql, questions)

    if commit:
        dbh.commit()
    else:
        dbh.rollback()
  
def parseQuestions(filename):
    qs_question_id = 0
    questions = []

    with open(filename) as f:
        next(f) # skip header 
        for line in f:
            line = line.strip()
            values = line.split("\t")
            qs_question_id = qs_question_id + 1
            values.insert(0, qs_question_id)
            questions.append(values)

    warning("DEBUG:", questions)
    return questions

def main(argv, dbAccess):
    dbh = None
    try:
        # read in questions
        questions = parseQuestions(argv.filename)

        database, host = dbAccess['dsn'].split(";")
        host = host.split("=")[1]
        database = database.split("=")[1]
        connection_string = "user='" + dbAccess['user'] 
        connection_string = connection_string + "' password='" + dbAccess['password']
        connection_string = connection_string + "' dbname='" + database
        connection_string = connection_string + "' host='" + host + "'"

        warning("DEBUG:", connection_string)
        dbh = psycopg2.connect(connection_string)

        createTable(dbh)
        loadQuestions(questions, dbh, argv.commit)

    except IOError:
        warning("FILE ERROR:", "Unable to open", argv.filename)

    except psycopg2.DatabaseError as e:
        if dbh is not None:
            dbh.rollback()
            warning("DATABASE ERROR:", str(e))
            sys.exit(1)
        else:
            warning("DATABASE ERROR:", str(e))

    finally:
        if dbh is not None:
            dbh.close()

if __name__ == '__main__':
    cml_parser = argparse.ArgumentParser()
    cml_parser.add_argument('-i', '--filename')
    cml_parser.add_argument('-c', '--commit', action='store_true')
    
    config_parser = SafeConfigParser()
    config_parser.readfp(FakeSecHead(open(os.environ['GUS_HOME'] + "/config/gus.config")))

    dbAccess = {'dsn': config_parser.get('section', 'dbiDsn'), 
                'user': config_parser.get('section', 'databaseLogin'),
                'password': config_parser.get('section', 'databasePassword')}

    main(cml_parser.parse_args(), dbAccess)

