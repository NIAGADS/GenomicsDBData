#!/usr/bin/env python 
#pylint: disable=invalid-name

'''
Generates load file for 1000 genomes frequencies
'''

from __future__ import with_statement
from __future__ import print_function

# from Bio.Seq import Seq

import argparse
import os.path as path
from os import listdir
import gzip
import datetime
import csv

from CBILDataCommon.Util.utils import qw, xstr, warning, die, verify_path
from CBILDataCommon.Util.postgres_dbi import Database

RS_SQL="""
SELECT find_variant_by_refsnp(%s) AS variant_id
"""

VARIANT_MATCH_SQL="""
	SELECT v.variant_id, ref_allele, alt_allele
	FROM NIAGADS.Variant v 
	WHERE bin_index = (SELECT find_bin_index(%s, %s, %s)) AND POSITION = %s
"""


def match_variant_by_refsnp(cursor, markers):
    variants = []
    for rs in markers:
        cursor.execute(RS_SQL, (rs,))
        for record in cursor:
            variants.append(record['variant_id'])
    if not variants:
        return None
    return variants


def get_matched_variant(cursor, chromosome, position, allele):
    ''' only care about the position and allele for frequency '''
    cursor.execute(VARIANT_MATCH_SQL, (chromosome, position, position, position))
    variants = []
    for record in cursor:
        if record['ref_allele'] == allele or record['alt_allele'] == allele:
            variants.append(record['variant_id'])

    # dont want to map to two variants ;e.g. if variant is multiallelic and is G:A and G:T and there is potentially a frequency for G:T
    # so skip reverseComp
  
    if not variants:
        return None
    return variants


def extract_frequency(infoStr, population):
    '''
    extract frequency for given population from info string
    '''
    # warning(infoStr)

    infoTags = dict(item.split('=') for item in infoStr.split(';')  if '=' in item)

    tag = population + '_AF' if population != 'GAF' else 'AF'

    if tag in infoTags:
        return infoTags[tag]
    else:
        return None
    


def generate_file_names():
    ''' 
    create hash of file names, one per population
    '''
    files = {}
    for p in populations:
        files[p] = path.join(args.outputDir, 'preprocess_1000GenomesFreq_' + p + '.txt')
        warning("Created", files[p])
    return files


def print_headers(files):
    '''
    print file headers
    '''
    fields = qw('variant_id allele frequency')
    for fname in files.itervalues():
        with open(fname, 'w') as of:
            print('|'.join(fields), file=of)


def generate_load_file():
    '''
    parse input file and generate load file
    '''

    files = generate_file_names()
    print_headers(files)

    cursor = database.cursor("RealDictCursor")
    count = 0
    skipCount = 0
    for filename in listdir(args.inputDir):
        if filename.endswith(".gz"):
            warning("Processing:", filename)
            with gzip.open(path.join(args.inputDir, filename)) as f:
                reader = csv.DictReader((row for row in f if not row.startswith('##')), delimiter='\t')
                for row in reader:
                    chromosome = row['#CHROM']
                    if chromosome == 'MT':
                        chromosome = 'M'
                    if chromosome == '23':
                        chromosome = 'X'

                    if '<' in row['ALT']:
                        skipCount = skipCount + 1
                        continue # not an interpretable variant at this time

                    alleles = row['ALT'].split(',') # multi-alleleic

                    refsnp = row['ID']
                    if 'es' in refsnp:
                        skipCount = skipCount + 1
                        continue # not an interpretable variant at this time

                    variants = None
                    for index, alt in enumerate(alleles):
                        metaseqId = chromosome + ':' + xstr(row['POS']) + ':' + row['REF'] + ':' + alt

                        # match position and allele first
                        variants = get_matched_variant(cursor, 'chr' + xstr(chromosome), row['POS'], alt)

                        if args.verbose and variants: 
                                warning("Matched:", metaseqId, '(' + refsnp  + ')', "to", variants, "by position.") 

                        if not variants: # if could not match position/allele try the refsnp ids
                            # if the # of refsnps = # alleles, map according to the index
                            # otherwise can't discriminate multiallelic variants and so need to map
                            # the allele/freq to all refsnps
                            markers = refsnp.split(';')
                            if len(markers) == len(alleles):
                                variants = match_variant_by_refsnp(cursor, [markers[index]])
                            else:
                                variants = match_variant_by_refsnp(cursor, markers)

                            if args.verbose and variants: 
                                warning("Matched:", metaseqId, '(' + refsnp  + ')', "to", variants, "by refsnp.") 

                        if variants:
                            print_population_frequencies(files, variants, alt, index, row['INFO'])

                        else:
                            warning("Unable to match:",  metaseqId, '(' + refsnp  + ')')

                    count = count + 1
                    if count % 500000 == 0:
                        warning("Processed " + xstr(count) + " rows")

    cursor.close()
    warning("Processed " + xstr(count) + " rows")


def print_population_frequencies(files, variants, allele, index, frequencies):
    ''' print frequencies for a given marker/allele to the files '''
    for p in populations:
        freq = extract_frequency(frequencies, p)
        if freq is not None:
            freqA = freq.split(',')
            alleleFreq = freqA[index]
            if alleleFreq == "0":
                continue

            with open(files[p], 'a') as of:
                for variantId in variants:
                    print('|'.join((xstr(variantId), allele, alleleFreq)), file=of)



def reverseComp(allele):
    ''' limiting to single alleles '''
    alleleMap = {'A': 'T', 'T':'A', 'C':'G', 'G':'C'}
 
    return alleleMap[allele]

    # return str(Seq(allele).reverse_complement())


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="generate 1000 Genomes Allele frequency load file")
    parser.add_argument('--outputDir', help="output file directory", required=True)
    parser.add_argument('--inputDir', help="input file directory", required=True)
    parser.add_argument('--populations', help="comma separated list of populations", required=True)
    parser.add_argument('--verbose', action='store_true')
    parser.add_argument('--gusConfigFile',
                        help="GUS config file. If not provided, assumes default: $GUS_HOME/conf/gus.config")
    args = parser.parse_args()

    database = Database(args.gusConfigFile)
    database.connect()

    populations = args.populations.split(',')
    generate_load_file()

    database.close()
